# Lec1 Intro&MapReduce

## Intro

分布式系统的核心，简单来讲就是**通过网络通信的方式，协调多台计算机完成任务**。

例如 k-v分布式存储，MapReduce分布式计算，p2p的文件共享等等

（实际上分布式并不是完美的方法，它会带来很多复杂的问题，能用单机解决的就用单机）

> 为什么要用分布式

- 需要**更高的算力**性能：多台计算机意味着大量的并行计算，大量的CPU、内存、磁盘等等
- 可以**实现容灾**：一台计算机发生问题，可以有备份
- **天然物理分布**
- 可以实现部署一些**offline机器**，更安全

> 分布式有哪些难点

- 因为系统中存在很多部分，这些部分又在并发执行，因此会遇到并发编程和各种复杂交互所带来的问题，以及时间依赖的问题（比如同步，异步）。这让分布式系统变得很难。
- 由于依赖网络传输，可能导致一些意想不到的问题

## Lecture Target

整个课程主要实现的是分布式的基础设施：**存储、计算、网络传输**

实际上最关注的是存储和计算这部分，至于通信，往往是我们实现计算和存储的工具

需要达成的目标就是，提供一套对外接口，使得外部使用者，像使用非分布式存储和计算一样便捷，但实际上有极高的性能和容错性

要达成这些目的，常用到：

* RPC作通信方式
* 多线程，使得我们可以利用多核心
* 锁，并发控制

## 分布式系统关注哪些问题？

**Scalability、Availability、Recoverability、Consistency**

**Scalability**是指可扩展性

> 分布式系统的可扩展性是指，只要增加计算机的数量，进行**平行扩展**，即可实现性能的平行扩展。（例如吞吐x2，性能x2）
>
> 例如一个WEB系统，为了扛更大的并发量，可以将WEB服务分布到多个服务器，用户进来后访问不同的服务器；更进一步，如果单机DB访问成为了瓶颈，可以将DB也扩展为多机，这就能扛下很大的并发了。
>
> 虽然平行扩展可以解决很多问题，但实际上我们需要一些架构设计将这个可扩展性无限推进下去。

**Availability**是指可用性

> 分布式系统的可用性是指**容错**
>
> 当我们使用一套分布式系统时，将涉及很多台服务器，很难防止有机器故障问题，要么机器故障，要么是运行出错，要么是运行缓慢，要么是执行错误的任务，以及最容易出现错误的网络问题
>
> 因此我们在设计系统时，要考虑系统能**屏蔽错误**/在出现错误时可以继续执行。

**Recoverbility**是指可恢复性

> 分布式系统的可恢复性是指出现问题后，系统**不再响应请求**，有人修复后才可以正常运行
>
> 要实现可恢复，一般采用以下两种方案：
>
> - 非易失存储
> - 复制
>
> 非易失存储类似于硬盘，即将数据/log等写入，永久性存储，可恢复，但问题在于经常写入会影响性能。
>
> 复制，即构建多副本系统，问题在于一致性问题很复杂。

**Consistency**是指一致性

> 以最简单的KV存储举例
>
> - 单机情况下：put(k, v)就是更新表单，get(k)就是获取值
> - 分布式情况下：由于存在复制/缓存问题，数据可能存在多个副本中，可能出现多个不同版本的k-v对。这时多个机器的一致性就成了问题。因此在实际操作中，put和get并不只是更新/获取那么简单。
>
> 实际上一致性也分很多种，这取决于我们对业务的要求
>
> - **强一致性**：get请求，不论打到哪台机器上，只能获取到最新更新的数据，不允许有旧数据出现
> - **弱一致性**：get请求可能获取到旧数据，也允许这样
>
> 如何实现强一致性？
>
> 强一致性一定会牺牲一定的性能，例如有两个副本，为了强一致性我们可以通过所有副本分别请求一次，取出最新的那个版本。但这就导致了多次昂贵的冗余通信。
>
> 因此在现实场景下，常常使用弱一致性系统，为了使得弱一致性有更强的意义，会定义一些场景特定的规则。

## MapReduce

这里建议先阅读MapReduce的论文。

![image](/Users/liuwenshuo/Documents/Notes/6.824/Lectures/image.png)

以上这个图是对MapReduce的最直观的解释，是以Word Count场景为例（利用一个分布式系统对多个文件进行词语统计），解释MapReduce具体做了什么。

Map任务：参数是文件名称+文件内容，首先将文件内容拆分为多个单词，将每个词转换为{"${WORD}", "1"}这样的key（单词）-value（"1"）对。因此可以看到，编写Map函数完全不需要考虑分布式的问题

Reduce任务：参数是当前计算的单词+对应输出的字符串"1"的数组，因此我们只关心数组的长度。可见编写Reduce函数也不需要考虑分布式问题

当所有Map任务都完成后，才会开始进行Reduce任务，reduce任务针对key相同（单个单词）的键值对进行统计，得到每个键（每个单词）的总个数。

以上只是Word Count场景下的MapReduce。**实际上我们关注的点并非map和reduce任务具体做了什么，而是要实现一个框架用来使用和调度map和reduce任务**。在后续的Lab中，会实现这样一个MapReduce框架。但所有的Map task和Reduce task实际上可以总结为做了以下的事情：Map将输入的k-v转换为中间k-v list，Reduce将中间k-v list转换为最终的结果。

```shell
Map(k1, v1) -> list(k2, v2)
Reduce(k2, list(v2)) -> list(v2)
```

MapReduce论文中是如下图所示进行的任务进行和调度：

<img src="/Users/liuwenshuo/Documents/Notes/6.824/Lectures/%E6%9C%AA%E5%91%BD%E5%90%8D%E5%9B%BE%E7%89%87.png" alt="未命名图片" style="zoom:50%;" />

整个系统分为Master和Worker两种程序。Master只有一个，负责进行任务的调度；worker进程则是多个并行；负责执行Map、Reduce任务。具体实现在Lab中，这里不进行详细描述。

