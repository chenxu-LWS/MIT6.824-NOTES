# Lec3 Distributed File System - GFS - PART3⃣️

## GFS综述

GFS可以说是分布式系统在当时为数不多的在工业界被应用的例子之一。Google拥有远超单个磁盘容量的数据要处理，并且需要借助例如MapReduce这种工具快速处理数据。因此，Google需要能够快速的并行访问海量数据。

GFS是Google针对大型、快速的全局(Global)分布式文件系统的一种解决方案，且这个文件系统可以被不同的应用程序进行读取和访问。

特点：

* 为了获取大容量、高性能，每个包含数据的文件都会被GFS分割（Sharding）并存放在多个服务器中；
* 运行在多台服务器，我们希望可以进行自动的故障修复（Automatic Recovery）；
* GFS提出存储系统接受弱一致性，以此来提供更高的性能；
* 单Master节点进行工作。

局限性：

* 单个GFS在设计上只有一个数据中心，没有将副本保存在世界各地，但实际上多个副本应该距离相对远。
* GFS并不面向普通用户，仅供内部使用
* GFS对大型顺序文件的读写做了定制化，但对小文件读取的性能并不是很好。GFS是为TB级别的文件而生，只会进行顺序处理，不支持随机访问，其关注点在于巨大的吞吐量，单次操作都涉及到MB级别的数据。

## GFS Master

GFS的Master节点是双机热备份（Active-Standby）模式，即虽然可能Master有多个节点，但只有一个真正在工作。Master上保存的是文件名-存储位置的哈希关系。

真正的文件数据存储在其他服务器，Master节点记录每个文件对应的所有Chunk的ID，每个Chunk大小为64MB。例如有一个1GB的文件，Master就需要知道其第一个Chunk存储在哪里，第二个存储在哪里...这也实现了可以进行一定程度上的"随机"读取。

Master中实际存储的内容主要是两个Map：

* 文件名 ---- ChunkID/Chunk Handle数组的第一条记录位置
* ChunkID ---- Chunk Detail
  * 其中Chunk Detail包含：
    * Chunk存储在哪一台服务器；
    * Chunk的当前版本号；
    * 由于Chunk是主从的，写入只在主Chunk进行，因此需要记录哪一台服务器记录了主Chunk；
    * 主Chunk的过期时间

以上数据都存储在内存，因此如果没有持久化机制，一旦Master宕机整个系统就崩了。所以Master的机制是读数据只从内存读，但写数据时要持久化到硬盘。实际上Master会在磁盘记录log，当有数据发生变更时，Master会在磁盘的log中追加记录并生成CheckPoint。

> 所以数据都需要进行持久化吗？
>
> A：并不是
>
> | 数据类型        | 详情                                                         | 是否易失（持久化到磁盘） |
> | --------------- | ------------------------------------------------------------ | ------------------------ |
> | ChunkHandle数组 | 文件对应的第一个Chunk的位置                                  | NV                       |
> | Chunk服务器列表 | Master发生重启后可以与其他服务器通信查询Chunk的存储服务器，因此不需持久化在Matser | V                        |
> | 版本号          | 取决于GFS的工作方式，认为是易失的，需要持久化                | NV                       |
> | 主Chunk的ID     | 每个主Chunk是有过期时间的，重启Master时等待过期时间结束后指定一个新的主Chunk即可 | V                        |
> | 过期时间        |                                                              | V                        |
>
> NV：Non-Volatile 非易失的，表示需要持久化到磁盘中。

依赖于这个基本机制，每个Chunk大小为64MB，一旦写入文件大小达到了新的64MB，则需要进行扩展，此时Master需要向磁盘追加一条log。可以看到每到64MB阈值，都需要进行磁盘写入，这十分消耗性能，因此使用GFS要尽可能减少写入数据到磁盘。

> 为什么使用log形式记录操作，而不是数据库？
>
> A：数据库实际上就是B树或者哈希表。由于对于记录常见的操作是一次性写入多条近期记录，这些记录都是向一个地址追加，只需等待磁盘的磁道旋转以此，而对于B树等结构，写入数据都是随机位置写入的。相比之下追加log到文件会更加高效。

同时为了加速Master故障后的修复，遍历所有log进行重建显然不可取，所以Master会在磁盘建立一些checkpoints，这样Master会从最近的一个checkpoint开始恢复，再逐条执行checkpoint以后的log即可。

